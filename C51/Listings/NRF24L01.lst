C51 COMPILER V9.54   NRF24L01                                                              05/25/2024 22:21:27 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE NRF24L01
OBJECT MODULE PLACED IN .\Objects\NRF24L01.obj
COMPILER INVOKED BY: D:\App\Keil_v5\C51\BIN\C51.EXE NRF24L01\NRF24L01.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRIN
                    -T(.\Listings\NRF24L01.lst) TABS(2) OBJECT(.\Objects\NRF24L01.obj)

line level    source

   1          #include <reg51.h>
   2          #include <intrins.h>
   3          #include <string.h>
   4          #include "NRF24L01.h"
   5          #include "../Utility/delay.h"
   6          
   7          uchar TX_ADDRESS[TX_ADR_WIDTH] = {0xFF, 0xFF, 0xFF, 0xFF, 0x00};       // ÂèëÈÄÅÂú∞ÂùÄ
   8          const uchar RX_ADDRESS[RX_ADR_WIDTH] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; // Êé•Êî∂Âú∞ÂùÄ
   9          
  10          uchar nrf24l01_buf[32];
  11          
  12          uchar SPI_RW(uchar byte)
  13          {
  14   1          uchar bit_ctr;
  15   1          for (bit_ctr = 0; bit_ctr < 8; bit_ctr++) // ËæìÂá∫8‰Ωç
  16   1          {
  17   2              NRF_MOSI = (byte & 0x80); // MSB TO MOSI
  18   2              byte = (byte << 1);       // shift next bit to MSB
  19   2              NRF_SCK = 1;
  20   2              byte |= NRF_MISO; // capture current MISO bit
  21   2              NRF_SCK = 0;
  22   2          }
  23   1          return byte;
  24   1      }
  25          
  26          /*********************************************/
  27          /* ÂáΩÊï∞ÂäüËÉΩÔºöÁªô24L01ÁöÑÂØÑÂ≠òÂô®ÂÜôÂÄºÔºà‰∏Ä‰∏™Â≠óËäÇÔºâ */
  28          /* ÂÖ•Âè£ÂèÇÊï∞Ôºöreg   Ë¶ÅÂÜôÁöÑÂØÑÂ≠òÂô®Âú∞ÂùÄ          */
  29          /*           value ÁªôÂØÑÂ≠òÂô®ÂÜôÁöÑÂÄº            */
  30          /* Âá∫Âè£ÂèÇÊï∞Ôºöstatus Áä∂ÊÄÅÂÄº                   */
  31          /*********************************************/
  32          uchar NRF24L01_Write_Reg(uchar reg, uchar value)
  33          {
  34   1          uchar status;
  35   1      
  36   1          NRF_CSN = 0;          // CSN=0;
  37   1          status = SPI_RW(reg); // ÂèëÈÄÅÂØÑÂ≠òÂô®Âú∞ÂùÄ,Âπ∂ËØªÂèñÁä∂ÊÄÅÂÄº
  38   1          SPI_RW(value);
  39   1          NRF_CSN = 1; // CSN=1;
  40   1      
  41   1          return status;
  42   1      }
  43          /*************************************************/
  44          /* ÂáΩÊï∞ÂäüËÉΩÔºöËØª24L01ÁöÑÂØÑÂ≠òÂô®ÂÄº Ôºà‰∏Ä‰∏™Â≠óËäÇÔºâ      */
  45          /* ÂÖ•Âè£ÂèÇÊï∞Ôºöreg  Ë¶ÅËØªÁöÑÂØÑÂ≠òÂô®Âú∞ÂùÄ               */
  46          /* Âá∫Âè£ÂèÇÊï∞Ôºövalue ËØªÂá∫ÂØÑÂ≠òÂô®ÁöÑÂÄº                */
  47          /*************************************************/
  48          uchar NRF24L01_Read_Reg(uchar reg)
  49          {
  50   1          uchar value;
  51   1      
  52   1          NRF_CSN = 0; // CSN=0;
  53   1          SPI_RW(reg); // ÂèëÈÄÅÂØÑÂ≠òÂô®ÂÄº(‰ΩçÁΩÆ),Âπ∂ËØªÂèñÁä∂ÊÄÅÂÄº
  54   1          value = SPI_RW(NOP);
C51 COMPILER V9.54   NRF24L01                                                              05/25/2024 22:21:27 PAGE 2   

  55   1          NRF_CSN = 1; // CSN=1;
  56   1      
  57   1          return value;
  58   1      }
  59          /*********************************************/
  60          /* ÂáΩÊï∞ÂäüËÉΩÔºöËØª24L01ÁöÑÂØÑÂ≠òÂô®ÂÄºÔºàÂ§ö‰∏™Â≠óËäÇÔºâ   */
  61          /* ÂÖ•Âè£ÂèÇÊï∞Ôºöreg   ÂØÑÂ≠òÂô®Âú∞ÂùÄ                */
  62          /*           *pBuf ËØªÂá∫ÂØÑÂ≠òÂô®ÂÄºÁöÑÂ≠òÊîæÊï∞ÁªÑ    */
  63          /*           len   Êï∞ÁªÑÂ≠óËäÇÈïøÂ∫¶              */
  64          /* Âá∫Âè£ÂèÇÊï∞Ôºöstatus Áä∂ÊÄÅÂÄº                   */
  65          /*********************************************/
  66          uchar NRF24L01_Read_Buf(uchar reg, uchar *pBuf, uchar len)
  67          {
  68   1          uchar status, u8_ctr;
  69   1          NRF_CSN = 0;          // CSN=0
  70   1          status = SPI_RW(reg); // ÂèëÈÄÅÂØÑÂ≠òÂô®Âú∞ÂùÄ,Âπ∂ËØªÂèñÁä∂ÊÄÅÂÄº
  71   1          for (u8_ctr = 0; u8_ctr < len; u8_ctr++)
  72   1              pBuf[u8_ctr] = SPI_RW(0XFF); // ËØªÂá∫Êï∞ÊçÆ
  73   1          NRF_CSN = 1;                     // CSN=1
  74   1          return status;                   // ËøîÂõûËØªÂà∞ÁöÑÁä∂ÊÄÅÂÄº
  75   1      }
  76          /**********************************************/
  77          /* ÂáΩÊï∞ÂäüËÉΩÔºöÁªô24L01ÁöÑÂØÑÂ≠òÂô®ÂÜôÂÄºÔºàÂ§ö‰∏™Â≠óËäÇÔºâ  */
  78          /* ÂÖ•Âè£ÂèÇÊï∞Ôºöreg  Ë¶ÅÂÜôÁöÑÂØÑÂ≠òÂô®Âú∞ÂùÄ            */
  79          /*           *pBuf ÂÄºÁöÑÂ≠òÊîæÊï∞ÁªÑ               */
  80          /*           len   Êï∞ÁªÑÂ≠óËäÇÈïøÂ∫¶               */
  81          /**********************************************/
  82          uchar NRF24L01_Write_Buf(uchar reg, uchar *pBuf, uchar len)
  83          {
  84   1          uchar status, u8_ctr;
  85   1          NRF_CSN = 0;
  86   1          status = SPI_RW(reg); // ÂèëÈÄÅÂØÑÂ≠òÂô®ÂÄº(‰ΩçÁΩÆ),Âπ∂ËØªÂèñÁä∂ÊÄÅÂÄº
  87   1          for (u8_ctr = 0; u8_ctr < len; u8_ctr++)
  88   1              SPI_RW(*pBuf++); // ÂÜôÂÖ•Êï∞ÊçÆ
  89   1          NRF_CSN = 1;
  90   1          return status; // ËøîÂõûËØªÂà∞ÁöÑÁä∂ÊÄÅÂÄº
  91   1      }
  92          
  93          /*********************************************/
  94          /* ÂáΩÊï∞ÂäüËÉΩÔºö24L01Êé•Êî∂Êï∞ÊçÆ                   */
  95          /* ÂÖ•Âè£ÂèÇÊï∞Ôºörxbuf Êé•Êî∂Êï∞ÊçÆÊï∞ÁªÑ              */
  96          /* ËøîÂõûÂÄºÔºö 0   ÊàêÂäüÊî∂Âà∞Êï∞ÊçÆ                 */
  97          /*          1   Ê≤°ÊúâÊî∂Âà∞Êï∞ÊçÆ                 */
  98          /*********************************************/
  99          uchar NRF24L01_RxPacket(uchar *rxbuf)
 100          {
 101   1          uchar state;
 102   1      
 103   1          state = NRF24L01_Read_Reg(STATUS);             // ËØªÂèñÁä∂ÊÄÅÂØÑÂ≠òÂô®ÁöÑÂÄº
 104   1          NRF24L01_Write_Reg(WRITE_REG + STATUS, state); // Ê∏ÖÈô§TX_DSÊàñMAX_RT‰∏≠Êñ≠Ê†áÂøó
 105   1          if (state & RX_OK)                             // Êé•Êî∂Âà∞Êï∞ÊçÆ
 106   1          {
 107   2              NRF_CE = 0;
 108   2              NRF24L01_Read_Buf(RD_RX_PLOAD, rxbuf, RX_PLOAD_WIDTH); // ËØªÂèñÊï∞ÊçÆ
 109   2              NRF24L01_Write_Reg(FLUSH_RX, 0xff);                    // Ê∏ÖÈô§RX FIFOÂØÑÂ≠òÂô®
 110   2              NRF_CE = 1;
 111   2              delay_us(150);
 112   2              return 0;
 113   2          }
 114   1          return 1; // Ê≤°Êî∂Âà∞‰ªª‰ΩïÊï∞ÊçÆ
 115   1      }
 116          /**********************************************/
C51 COMPILER V9.54   NRF24L01                                                              05/25/2024 22:21:27 PAGE 3   

 117          /* ÂáΩÊï∞ÂäüËÉΩÔºöËÆæÁΩÆ24L01‰∏∫ÂèëÈÄÅÊ®°Âºè              */
 118          /* ÂÖ•Âè£ÂèÇÊï∞Ôºötxbuf  ÂèëÈÄÅÊï∞ÊçÆÊï∞ÁªÑ              */
 119          /* ËøîÂõûÂÄºÔºõ 0x10    ËææÂà∞ÊúÄÂ§ßÈáçÂèëÊ¨°Êï∞ÔºåÂèëÈÄÅÂ§±Ë¥•*/
 120          /*          0x20    ÊàêÂäüÂèëÈÄÅÂÆåÊàê              */
 121          /*          0xff    ÂèëÈÄÅÂ§±Ë¥•                  */
 122          /**********************************************/
 123          uchar NRF24L01_TxPacket(uchar *txbuf)
 124          {
 125   1          uchar state;
 126   1          NRF_CE = 0;                                             // CEÊãâ‰ΩéÔºå‰ΩøËÉΩ24L01ÈÖçÁΩÆ
 127   1          NRF24L01_Write_Buf(WR_TX_PLOAD, txbuf, TX_PLOAD_WIDTH); // ÂÜôÊï∞ÊçÆÂà∞TX BUF  32‰∏™Â≠óËäÇ
 128   1          NRF_CE = 1;                                             // CEÁΩÆÈ´òÔºå‰ΩøËÉΩÂèëÈÄÅ
 129   1          while (NRF_IRQ == 1)
 130   1              ;                                          // Á≠âÂæÖÂèëÈÄÅÂÆåÊàê
 131   1          state = NRF24L01_Read_Reg(STATUS);             // ËØªÂèñÁä∂ÊÄÅÂØÑÂ≠òÂô®ÁöÑÂÄº
 132   1          NRF24L01_Write_Reg(WRITE_REG + STATUS, state); // Ê∏ÖÈô§TX_DSÊàñMAX_RT‰∏≠Êñ≠Ê†áÂøó
 133   1          if (state & MAX_TX)                            // ËææÂà∞ÊúÄÂ§ßÈáçÂèëÊ¨°Êï∞
 134   1          {
 135   2              NRF24L01_Write_Reg(FLUSH_TX, 0xff); // Ê∏ÖÈô§TX FIFOÂØÑÂ≠òÂô®
 136   2              return MAX_TX;
 137   2          }
 138   1          if (state & TX_OK) // ÂèëÈÄÅÂÆåÊàê
 139   1          {
 140   2              return TX_OK;
 141   2          }
 142   1          return 0xff; // ÂèëÈÄÅÂ§±Ë¥•
 143   1      }
 144          
 145          void NRF24L01_TX_Mode(uchar *tx_addr)
 146          {
 147   1          NRF_CE = 0;
 148   1          NRF24L01_Write_Buf(WRITE_REG + TX_ADDR, tx_addr, TX_ADR_WIDTH); // ÂÜôTXËäÇÁÇπÂú∞ÂùÄ
 149   1          NRF24L01_Write_Reg(WRITE_REG + CONFIG, 0x0e);
 150   1          // NRF24L01_Write_Reg(FLUSH_RX, 0xff);
 151   1          // NRF24L01_Write_Reg(FLUSH_TX, 0xff);
 152   1          NRF_CE = 1;
 153   1      }
 154          
 155          void NRF24L01_RX_Mode(void)
 156          {
 157   1          NRF_CE = 0;
 158   1          NRF24L01_Write_Reg(WRITE_REG + CONFIG, 0x0F);
 159   1          // NRF24L01_Write_Reg(FLUSH_RX, 0xff);
 160   1          // NRF24L01_Write_Reg(FLUSH_TX, 0xff);
 161   1          NRF_CE = 1;
 162   1      }
 163          
 164          /********************************************/
 165          /* ÂáΩÊï∞ÂäüËÉΩÔºöÊ£ÄÊµã24L01ÊòØÂê¶Â≠òÂú®              */
 166          /* ËøîÂõûÂÄºÔºõ  0  Â≠òÂú®                        */
 167          /*           1  ‰∏çÂ≠òÂú®                      */
 168          /********************************************/
 169          uchar NRF24L01_Check(void)
 170          {
 171   1          uchar check_in_buf[5] = {0x11, 0x22, 0x33, 0x44, 0x55};
 172   1          uchar check_out_buf[5] = {0x00};
 173   1      
 174   1          NRF_SCK = 0;
 175   1          NRF_CSN = 1;
 176   1          NRF_CE = 0;
 177   1      
 178   1          NRF24L01_Write_Buf(WRITE_REG + TX_ADDR, check_in_buf, 5);
C51 COMPILER V9.54   NRF24L01                                                              05/25/2024 22:21:27 PAGE 4   

 179   1      
 180   1          NRF24L01_Read_Buf(READ_REG + TX_ADDR, check_out_buf, 5);
 181   1      
 182   1          if ((check_out_buf[0] == 0x11) &&
 183   1              (check_out_buf[1] == 0x22) &&
 184   1              (check_out_buf[2] == 0x33) &&
 185   1              (check_out_buf[3] == 0x44) &&
 186   1              (check_out_buf[4] == 0x55))
 187   1              return 0;
 188   1          else
 189   1              return 1;
 190   1      }
 191          
 192          void NRF24L01_Init(void)
 193          {
 194   1          while (NRF24L01_Check())
 195   1              ; // Á≠âÂæÖÊ£ÄÊµãÂà∞NRF24L01ÔºåÁ®ãÂ∫èÊâç‰ºöÂêë‰∏ãÊâßË°å
 196   1      
 197   1          NRF_CE = 0;
 198   1          NRF24L01_Write_Reg(WRITE_REG + RX_PW_P0, RX_PLOAD_WIDTH);                      // ÈÄâÊã©ÈÄöÈÅì0ÁöÑÊúâÊ
             -ïàÊï∞ÊçÆÂÆΩÂ∫¶
 199   1          NRF24L01_Write_Reg(FLUSH_RX, 0xff);                                            // Ê∏ÖÈô§RX FIFOÂØÑÂ≠òÂ
             -ô®
 200   1          NRF24L01_Write_Buf(WRITE_REG + TX_ADDR, (uchar *)TX_ADDRESS, TX_ADR_WIDTH);    // ÂÜôTXËäÇÁÇπÂú∞ÂùÄ
 201   1          NRF24L01_Write_Buf(WRITE_REG + RX_ADDR_P0, (uchar *)RX_ADDRESS, RX_ADR_WIDTH); // ËÆæÁΩÆTXËäÇÁÇπÂú∞ÂùÄ
             -,‰∏ªË¶Å‰∏∫‰∫Ü‰ΩøËÉΩACK
 202   1          NRF24L01_Write_Reg(WRITE_REG + EN_AA, 0x01);                                   // ‰ΩøËÉΩÈÄöÈÅì0ÁöÑËá™Â
             -ä®Â∫îÁ≠î
 203   1          NRF24L01_Write_Reg(WRITE_REG + EN_RXADDR, 0x01);                               // ‰ΩøËÉΩÈÄöÈÅì0ÁöÑÊé•Ê
             -î∂Âú∞ÂùÄ
 204   1          NRF24L01_Write_Reg(WRITE_REG + SETUP_RETR, 0x1a);                              // ËÆæÁΩÆËá™Âä®ÈáçÂèëÈó
             -¥ÈöîÊó∂Èó¥:500us + 86us;ÊúÄÂ§ßËá™Âä®ÈáçÂèëÊ¨°Êï∞:10Ê¨°
 205   1          NRF24L01_Write_Reg(WRITE_REG + RF_CH, 0);                                      // ËÆæÁΩÆRFÈÄöÈÅì‰∏∫2.4
             -00GHz  È¢ëÁéá=2.4+0GHz
 206   1          NRF24L01_Write_Reg(WRITE_REG + RF_SETUP, 0x0F);                                // ËÆæÁΩÆTXÂèëÂ∞ÑÂèÇÊï∞
             -,0dbÂ¢ûÁõä,2Mbps,‰ΩéÂô™Â£∞Â¢ûÁõäÂºÄÂêØ
 207   1          NRF24L01_Write_Reg(WRITE_REG + CONFIG, 0x0f);                                  // ÈÖçÁΩÆÂü∫Êú¨Â∑•‰ΩúÊ®
             -°ÂºèÁöÑÂèÇÊï∞;PWR_UP,EN_CRC,16BIT_CRC,Êé•Êî∂Ê®°Âºè,ÂºÄÂêØÊâÄÊúâ‰∏≠Êñ≠
 208   1          NRF24L01_Write_Reg(FLUSH_RX, 0xff);
 209   1          NRF24L01_Write_Reg(FLUSH_TX, 0xff);
 210   1          NRF_CE = 1; // CEÁΩÆÈ´òÔºå‰ΩøËÉΩÂèëÈÄÅ
 211   1      }
 212          
 213          void NRF24L01_TxHalfDuplex(uchar *buf, uchar addr)
 214          {
 215   1          TX_ADDRESS[4] = addr;
 216   1      
 217   1          NRF24L01_TX_Mode(TX_ADDRESS);
 218   1      
 219   1          delay_us(15);
 220   1      
 221   1          NRF24L01_TxPacket(buf);
 222   1      
 223   1          NRF24L01_RX_Mode();
 224   1      }
 225          
 226          void TestNRF24L01()
 227          {
 228   1          NRF24L01_Init();
 229   1          while (1)
 230   1          {
 231   2              if (NRF_IRQ == 0) // Â¶ÇÊûúÊó†Á∫øÊ®°ÂùóÊé•Êî∂Âà∞Êï∞ÊçÆ
C51 COMPILER V9.54   NRF24L01                                                              05/25/2024 22:21:27 PAGE 5   

 232   2              {
 233   3                  if (!NRF24L01_RxPacket(nrf24l01_buf))
 234   3                  {
 235   4                      NRF24L01_TxHalfDuplex(nrf24l01_buf, 0xA5); // Êé•Êî∂Êï∞ÊçÆÂêéÔºåÂõû‰º†
 236   4      
 237   4                      if (nrf24l01_buf[1] == '1') // Á¨¨1‰Ωç‰ª•ÂêéÊòØÊî∂Âà∞ÁöÑÂëΩ‰ª§Êï∞ÊçÆÔºårece_buf[0]ÊòØÊï∞Êç
             -Æ‰ΩçÊï∞ÈïøÂ∫¶
 238   4                          LED = 0;
 239   4                      if (nrf24l01_buf[1] == '2') // Á¨¨1‰Ωç‰ª•ÂêéÊòØÊî∂Âà∞ÁöÑÂëΩ‰ª§Êï∞ÊçÆÔºårece_buf[0]ÊòØÊï∞Êç
             -Æ‰ΩçÊï∞ÈïøÂ∫¶
 240   4                          LED = 1;
 241   4                  }
 242   3              }
 243   2      
 244   2              delay_ms(10);
 245   2          }
 246   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    565    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     42      26
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
