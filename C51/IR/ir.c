/**************************************************************************************
*		              红外通信实验												  *
实现现象：	具体接线操作请参考视频
			下载程序后，数码管显示红外遥控键值数据
注意事项：	红外遥控模块的短接片J1短接，
			红外遥控器内的电池绝缘片一定要抽掉
***************************************************************************************/

#include "reg52.h" //此文件中定义了单片机的一些特殊功能寄存器
#include <intrins.h>
#include "ir.h"
#include "../Utility/CommData.h"
#include "../LED/DynamicLed.h"
#include "../Utility/delay.h"

typedef unsigned int u16; // 对数据类型进行声明定义
typedef unsigned char u8;

sbit IRIN = P3 ^ 2; //  P3.2/INT0

u8 IrValue[6];

/*******************************************************************************
 * 函数名         : IrInit()
 * 函数功能		   : 初始化红外线接收
 * 输入           : 无
 * 输出         	 : 无
 *******************************************************************************/

void IrInit()
{
	IT0 = 1; // 下降沿触发
	EX0 = 1; // 打开中断0允许
	EA = 1;	 // 打开总中断

	IRIN = 1; // 初始化端口
}

/*******************************************************************************
 * 函数名         : ReadIr()
 * 函数功能		   : 读取红外数值的中断函数
 * 输入           : 无
 * 输出         	 : 无
 *******************************************************************************/

// 数据格式：起始码(9ms 低电平 + 4.5ms 高电平)、用户码、用户反码、数据码、数据码反码
void ReadIr() interrupt 0
{
	u8 j, k;
	u16 err;
	u8 Time = 0;
	delay_10us(700); // 7ms
	if (IRIN == 0)	 // 确认是否真的接收到正确的信号
	{
		// 9ms 低电平
		err = 1000;						 // 1000*10us=10ms,超过说明接收到错误的信号
		while ((IRIN == 0) && (err > 0)) // 等待前面9ms的低电平过去
		{
			delay_10us(1);
			err--;
		}
		if (IRIN == 1) // 如果正确等到9ms低电平
		{
			err = 500;
			// 4.5ms 高电平
			while ((IRIN == 1) && (err > 0)) // 等待4.5ms的起始高电平过去
			{
				delay_10us(1);
				err--;
			}

			// 数据：用户码、用户反码、数据码、数据码反码
			for (k = 0; k < 4; k++) // 共有4组数据
			{
				for (j = 0; j < 8; j++) // 接收一组数据
				{
					// 0.56ms 低电平
					err = 60;
					while ((IRIN == 0) && (err > 0)) // 等待信号前面的560us低电平过去
					{
						delay_10us(1);
						err--;
					}

					// 脉冲位置调制：度量高电平的时间长度
					err = 500;
					while ((IRIN == 1) && (err > 0)) // 计算高电平的时间长度。
					{
						delay_10us(10); // 0.1ms
						Time++;
						err--;
						if (Time > 30)
						{
							return;
						}
					}

					IrValue[k] >>= 1; // k表示第几组数据  (读数据 >>= 在前，写数据 >>= 在后)
					if (Time >= 8)	  // 如果高电平出现大于565us，那么是1
					{
						IrValue[k] |= 0x80;
					}
					Time = 0; // 用完时间要重新赋值
				}
			}
		}
		if (IrValue[2] != ~IrValue[3])
		{
			return;
		}
	}
}

void TestIR()
{
	IrInit();
	while (1)
	{
		DisplayData[0] = smgduan[IrValue[2] / 16];
		DisplayData[1] = smgduan[IrValue[2] % 16];
		DisplayData[2] = smgduan[16];
		DigDisplay();
	}
}