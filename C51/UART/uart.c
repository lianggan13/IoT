/**************************************************************************************
*		              串口通信实验												  *
实现现象：下载程序后打开串口调试助手，将波特率设置为4800，选择发送的数据就可以显示
            在串口助手上。具体操作参考操作视频
注意事项：无。

    VCC--5V
    RXD--P3.1 (TXD)
    TXD--P3.0 (RXD)
    GND--GND
***************************************************************************************/

#include "reg52.h" //此文件中定义了单片机的一些特殊功能寄存器
#include "uart.h"

#define FOSC 11059200 // 单片机晶振频率
#define BAUD 4800     // 波特率设置为9600

typedef unsigned int u16; // 对数据类型进行声明定义
typedef unsigned char u8;

void UsartInit01()
{
    // 设定串行口的工作方式、接收/发送控制以及设置状态标志
    // SM0 SM1，工作方式选择位，可选择四种工作方式: 方式1 10位异步收发器(8bit数据)
    // SM2，多机通信控制位
    // REN，允许串行接收位
    // TB8，在方式2或方式3中，是发送数据的第九位
    // RB8，在方式2或方式3中，是接收到数据的第九位
    // TI，发送中断标志位。
    // RI，接收中断标志位
    SCON = 0X50; // 设置为模式1，8位数据，可变波特率

    // 串口设置9600波特率的时候总是接收不到正确数据
    // 因为12Mhz的单片机9600波特通信设置T1初值为FD时有8.51%的误差，而允许误差为4.5%以下
    // 解决方法：用4800波特率，置SMOD为1通信，此时误差只有0.16%
    TMOD = 0X20; // 设置计数器T1工作方式2 8位 自动重装载
    // TH1 = 0XF3;  // 计数器初始值设置，0XF3 x2:4800
    // TL1 = 0XF3;

    TH1 = 256 - 3;
    TL1 = 256 - 3;

    ES = 1;  // 打开接收串口中断
    EA = 1;  // 打开总中断
    TR1 = 1; // 打开计数器
}

void UsartInit02()
{
    SCON = 0x50; // 串口配置为工作方式1
    PCON = 0;    // 波特率不加倍

    TMOD = 0x20;                             // 设置定时器1为8位自动重装模式
    TH1 = TL1 = 256 - FOSC / 32 / 12 / BAUD; // 定时器1赋初始值

    ET1 = 0; // 禁止定时器1中断
    TR1 = 1; // 启动定时器1

    ES = 1; // 允许串口中断
}

// void Usart() interrupt 4
// {
//     u8 receiveData;

//     receiveData = SBUF; // 出去接收到的数据
//     RI = 0;             // 串行接收停止位的中间时，由内部硬件使RI置1，向CPU发中断申请。也必须在中断服务程序中，用软件将其清0，取消此中断申请
//     SBUF = receiveData; // 将接收到的数据放入到发送寄存器
//     while (!TI)
//         ;   // 等待发送数据完成
//     TI = 0; // 串行发送停止位的开始时，由内部硬件使TI置1，向CPU发中断申请。在中断服务程序中，必须用软件将其清0，取消此中断申请。
// }

// 串口接收中断服务程序
void UART_ISR() interrupt 4
{
    if (RI)
    {
        u8 receiveData = SBUF;

        RI = 0; // 清除接收中断标志

        SBUF = receiveData;
        while (!TI)
            ; // 等待发送数据完成
        TI = 0;
    }
}

void TestUART()
{
    UsartInit01();
    while (1)
        ;
}