/**************************************************************************************
*		              串口通信实验												  *
实现现象：下载程序后打开串口调试助手，将波特率设置为4800，选择发送的数据就可以显示
            在串口助手上。具体操作参考操作视频
注意事项：无。
***************************************************************************************/

#include "reg52.h" //此文件中定义了单片机的一些特殊功能寄存器

typedef unsigned int u16; // 对数据类型进行声明定义
typedef unsigned char u8;

/*******************************************************************************
 * 函数名         :UsartInit()
 * 函数功能		   :设置串口
 * 输入           : 无
 * 输出         	 : 无
 *******************************************************************************/
void UsartInit()
{

    TMOD = 0X20; // 设置计数器T1工作方式2 自动重装载
    TH1 = 0XF3;  // 计数器初始值设置，注意波特率是4800
    TL1 = 0XF3;

    // SMOD（PCON.7）  波特率倍增位。在串行口方式1、方式2、方式3时，波特率与SMOD有关，当SMOD=1时，波特率提高一倍
    PCON = 0X80; // 波特率加倍 x2

    // 设定串行口的工作方式、接收/发送控制以及设置状态标志
    // SM0和SM1为工作方式选择位，可选择四种工作方式: 方式1 10位异步收发器(8bit数据)
    // SM2，多机通信控制位
    // REN，允许串行接收位
    // TB8，在方式2或方式3中，是发送数据的第九位
    // RB8，在方式2或方式3中，是接收到数据的第九位
    // TI，发送中断标志位。
    // RI，接收中断标志位
    SCON = 0X50; // 设置为工作方式1 方式1的波特率 =（2SMOD/32）·（T1溢出率）

    ES = 1;  // 打开接收串口中断
    EA = 1;  // 打开总中断
    TR1 = 1; // 打开计数器
}

/*******************************************************************************
 * 函 数 名       : main
 * 函数功能		 : 主函数
 * 输    入       : 无
 * 输    出    	 : 无
 *******************************************************************************/
void main()
{
    UsartInit(); //	串口初始化
    while (1)
        ;
}

/*******************************************************************************
 * 函数名         : Usart() interrupt 4
 * 函数功能		  : 串口通信中断函数
 * 输入           : 无
 * 输出         	 : 无
 *******************************************************************************/
void Usart() interrupt 4
{
    u8 receiveData;

    receiveData = SBUF; // 出去接收到的数据
    RI = 0;             // 串行接收停止位的中间时，由内部硬件使RI置1，向CPU发中断申请。也必须在中断服务程序中，用软件将其清0，取消此中断申请
    SBUF = receiveData; // 将接收到的数据放入到发送寄存器
    while (!TI)
        ;   // 等待发送数据完成
    TI = 0; // 串行发送停止位的开始时，由内部硬件使TI置1，向CPU发中断申请。在中断服务程序中，必须用软件将其清0，取消此中断申请。
}